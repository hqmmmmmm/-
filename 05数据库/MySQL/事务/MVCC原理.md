Read View：可以理解为数据快照，记录某一时刻数据库的状态信息。

Read View中有四个字段
    creator_trx_id   创建该Read View的事务的事务ID
    m_ids            创建该Read View时数据库中活跃的事务列表（已启动但还未提交的事务）
    min_trx_id       创建该Read View时数据库中活跃的事务ID的最小值，即m_ids的最小值
    max_trx_id       创建该Read View时数据库中应该给下一个事务的ID值，即全局事务ID的最大值+1 


聚簇索引（主键索引）记录中有两个隐藏列
    trx_id         当一个事务对该记录进行操作时，会将自己的事务ID记录在trx_id中
    roll_pointer   当对该记录进行操作时，会将旧版本的记录写入undo日志中，roll_pointer会指向每一个旧版本记录，以链表的形式串联起来，形成版本链。


一个事务去访问记录的时候，自己的更新记录总是可见的。

---

可重复读隔离级别是如何工作的？

可重复读隔离级别，是在启动事务时会生成一个Read View，整个事务执行期间都用这个Read View。

当执行查询操作时，会先查找对应记录中的trx_id。
- 如果trx_id < min_trx_id，说明上一次对这个记录进行操作的事务在当前事务启动前就已经提交了，可以直接查询记录中的数据；
- 如果trx_id在min_trx_id和max_trx_id之间，则先会查找trx_id是否在m_ids中。
  - 如果在，则说明上一次对这个记录操作的事务在当前事务启动时还没有提交，会沿着roll_pointer指向的版本链寻找之前的版本；
  - 如果不在，也可以直接查询记录中的数据；
- 如果trx_id > max_trx_id, 说明上一次对这个记录进行操作的事务是在该事务启动后才提交的，也会寻找之前的版本。

_
                 ____小于min_trx_id         上一次对这个记录进行操作的事务在当前事务启动前就已经提交了，可以直接查询记录中的数据；
                |    
                |                    
                |                                 _____在m_ids中     上一次对该记录进行操作的事务在当前事务启动前还未提交，通过roll_pointer寻找之前的版本;
记录中的trx_id---                                 |
                |____min_trx_id和max_trx_id之间--- 
                |                                |_____不在m_ids中   上一次对这个记录进行操作的事务在当前事务启动前就已经提交了，可以直接查询记录中的数据；
                |
                |
                |____大于等于max_trx_id     上一次对这个记录进行操作的事务是在该事务启动后才启动并提交的，通过roll_pointer寻找之前的版本。

---

读提交是如何工作的？

读提交隔离级别，在每次执行一条语句之前，都会生成一个新的Read View.

其它原理同上。
