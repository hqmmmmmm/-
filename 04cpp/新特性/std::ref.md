std::thread库创建线程的时候，传递函数指针或者函数对象给参数，后续跟函数的参数，但是thread的构造函数其实和bind很类似：无论你这个线程函数是需要引用参数，还是需要值参数，起初传递给thread对象的都是值传递，而thread对象把值传递给线程函数的时候才会进行引用传递或者值传递，所以说，无论怎样都会有一次拷贝操作，而在thread或者bind对象析构的时候，这个值就会消失，从而造成一种假象：我明明传递了引用，而这个引用的值在线程函数里的改变却没有影响到原来的值。  

为了保证引用类型在经过函数模板或者类模板中的值传递过程中可以保持引用信息。这里面采用将传入变量包装成另外一个新的对象(reference_wrapper)，在这个新的对象中持有被包装对象的地址信息。在函数模板和类模板的值传递过程中，对这个新的对象进行值传递，其内部的被包装的对象地址信息可以得到保存。在函数模板或者内模板内部使用这个新的对象的时候，可以通过重载的类型转换函数将被包装变量的地址信息转换还原成相应的引用，对这个引用进行操作。从而达到操作外部变量的作用.  

解决方法：使用ref函数，表明使用左值引用传递。


[从示例到源码深入了解std::ref](https://zhuanlan.zhihu.com/p/581739392)  
[std::ref与std::reference_wrapper](https://zhuanlan.zhihu.com/p/654915585)